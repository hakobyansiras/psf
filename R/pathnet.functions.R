#' Map gene data onto a pathway graph
#'
#' @param g Tha pathway graph of graphNEL class
#' @param entrez.fc gene expression fold change matrix with entrez gene rownames (A matrix data associated with the genes; rownames represent genes; a single gene-row may contain one or many data values;)
#'
#' @return graphNEL object with the column-wise averaged gene data kept in the nodedata attribute of the graph
#' @export
map.gene.data <- function(g, entrez.fc){
  
  if(!("matrix" %in% class(entrez.fc))) {
    stop(paste0("ERROR: Provided expression data is in", class(entrez.fc), "class, provide expression matrix in matrix class"))
  }
  
  if(any(is.na(entrez.fc))) {
    stop("ERROR: expression matrix contain NA values")
  }
  
  if(any(entrez.fc == 0)) {
    stop("ERROR: expression matrix contain 0 values, make sure to provide expression fold change values")
  }
  
  gene.data <- graph::nodeData(g)
  gene.data <- lapply(gene.data, function (x,y) {
    genes.in.node = which(rownames(y) %in% x$genes)
    expression.values <- y[genes.in.node,]
    #         show(length(expression.values))
    if (length(expression.values)>0){
      if (x$type == "gene"){
        expression <- mean(expression.values)
        #         show(expression.values)
      }
      else { if(x$type == "group")
        expression <- min(expression.values)
      #         show(expression.values)
      }
    }
    else expression <-1

    #     show(expression)
    x$expression <- expression
    return(x)
  }, entrez.fc)
### added transition_gene to expression mapping(transition nodes will have default 1 expression)
  for(i in 1:length(gene.data)){
    if(gene.data[[i]]$type %in% c("gene", "transition_gene")) {
      graph::nodeData(g, names(gene.data)[i], "expression") =  gene.data[[i]]$expression
    } else {
      graph::nodeData(g, names(gene.data)[i], "expression") =  1
    }
  }
  return(g)
}


ensembl.id.conversion <- function(indata.FC, convert.from = "ensembl_gene_id", convert.to = "entrezgene"){

  z = rownames(indata.FC)

  cat("Loading biomart data table\n")
  #mart<-biomaRt::useMart('ensembl')
  mart = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", host="www.ensembl.org")
  mart <- biomaRt::useDataset("hsapiens_gene_ensembl", mart=mart)
  biomart.table = biomaRt::getBM( c(convert.from, convert.to), values = z, mart = mart,
                                  filters=convert.from, uniqueRows = T )

  na.ind = which(apply(apply(biomart.table, 2, is.na),1,any))
  if(length(na.ind) > 0)
    biomart.table = biomart.table[-na.ind, ]

  Entrez.FC = matrix(0, nrow = nrow(biomart.table), ncol = ncol(indata.FC))
  colnames(Entrez.FC) <- colnames(indata.FC)
  rownames(Entrez.FC) <- biomart.table[,2]

  cat("Performing ID conversion:\n")
  percent5 = base::floor(nrow(biomart.table)/20)
  # cat(percent5)
  perc = 0
  for(i in 1:nrow(biomart.table)) {
    if((i %% percent5) == 0){
      perc = perc + 5
      # show(i)
      cat(perc, "%\n")
    }
    gene.ID = biomart.table[i,1]
    #     Entrez.FC[i,] = indata.FC[which(tolower(rownames(indata.FC)) == tolower(gene.ID)),]
    row.index = which(tolower(z) == tolower(gene.ID))
    # if(length(row.index) != 0){
    if(length(row.index) > 1 )
      Entrez.FC[i,] = colMeans(indata.FC[row.index,])
    else
      Entrez.FC[i,] = indata.FC[row.index,]
    # }
  }


  return(Entrez.FC)
}


psf.from.env.indata <- function(indata.fc){
  entrez.fc = ensembl.id.conversion(indata.fc)
  return(psf.env.entrez.fc(entrez.fc))
}

#' Calculates pathway activity with PSF algorithm for provided kegg collection based on expression fold change data.
#' @param entrez.fc expression fold change matrix with gene etrez id rownames.
#' @param kegg.collection the list of kegg pathways generated by generate.kegg.collection.from.kgml or generate.kegg.collection function.
#' @param split logical, if true then the incoming signal will be proportionally splitted among the edges.
#' @param calculate.significance logical, if true then function will also calculate significance for the PSF values by shuffling all the network nodes and checking if the resulted PSF values were calculated by chance.
#' @param bst.steps integer, the number of the interations for shuffling and recalculating PSF values for the significance analysis.
#' @param sum logical, default value is FALSE. When set to true pathway activity will be caculated via addition, when set to false then activity willbe calculated via multiplication.
#' @param map_exp_data logical, default value is TRUE. When set to false the expression data will not be mapped into pathway nodes and pathway node expression values will be used instead.
#' @param return_only_signals logical, default value is FALSE. When set to true only PSF values of the pathway nodes will be retruned in the results. Set to TRUE when analyzing large datasets to reduce size of the output file.
#' @param tmm_mode when set to true specific PSF configuration will be used for the pathway activity calculation described in https://www.frontiersin.org/articles/10.3389/fgene.2021.662464/full
#' @param tmm_updated_mode when set to true specific PSF configuration will be used for the pathway activity calculation described in https://www.frontiersin.org/articles/10.3389/fgene.2021.662464/full
#' @export
psf.from.env.entrez.fc <- function(entrez.fc, kegg.collection, split = TRUE, calculate.significance = T, bst.steps = 200, sum = FALSE, map_exp_data = TRUE, return_only_signals = FALSE, tmm_mode = FALSE, tmm_updated_mode = FALSE){
  psf.results.collection = list()
  psf.results.collections = list()
  for(c in 1:ncol(entrez.fc)){
    # cat("Column", c)
    for(i in 1:length(kegg.collection)){
      cat(names(kegg.collection)[i], " exp matrix column: ", c, "\n")
      pathway = names(kegg.collection)[i]
      # show(pathway)
      if(!length(kegg.collection[[i]])==0){
        # cat("PSF computation on: ", pathway, "\n")
        entrez.column = as.matrix(entrez.fc[,c])
        if(map_exp_data) {
          ## reseting pathway signal values
          graph::nodeData(kegg.collection[[i]]$graph, attr = "signal") <- 1
          
          g = map.gene.data(kegg.collection[[i]]$graph, entrez.column)
        } else {
          graph::nodeData(kegg.collection[[i]]$graph, attr = "signal") <- 1
          
          g = kegg.collection[[i]]$graph
        }
        

        psf.results.collection[[pathway]] = psf.flow(g, kegg.collection[[i]]$order, kegg.collection[[i]]$sink.nodes, split, sum = sum, tmm_mode = tmm_mode, tmm_updated_mode = tmm_updated_mode)

        psf.results.collection[[pathway]] = c(psf.results.collection[[pathway]],
                                              attrs=list(kegg.collection[[i]]$attrs),
                                              order=list(kegg.collection[[i]]$order))

      }
    }
    if(calculate.significance){
      cat("\nPerforming bootstrap calculations with", bst.steps, " steps\n")
      psf.results = bootstrap.significance(psf.results.collection, entrez.fc, bst.steps)
      psf.results.processed = process.psf.results(psf.results)
    } else {
      psf.results.processed = psf.results.collection
    }

    if(return_only_signals) {
      psf.results.collections[[c]] <- lapply(psf.results.processed, function(x) {unlist(graph::nodeData(x$graph, attr = "signal"))})
    } else {
      psf.results.collections[[c]] = psf.results.processed
    }
  }
  
  names(psf.results.collections) <- colnames(entrez.fc)

  return(psf.results.collections)
}


bootstrap.significance <- function(psf.results, entrez.fc, bst.steps){
  for(i in 1:length(psf.results)){
    result.it = psf.results[[i]]
    cat("Performing bootstrap on: ", result.it$attrs$title, "\n")
    boot.mat = psf.flow.boot(result.it$graph, entrez.fc,
                             result.it$order, result.it$eval.exprs,
                             result.it$sink.nodes, result.it$I, bst.steps)
    psf.results[[i]] = c(psf.results[[i]], list(boot.mat=boot.mat))
  }
  return(psf.results)
}


psf.from.env.to.table <- function(env){
  if(is.null(env))
    stop("null env argument")

  if(!(kegg.collection %in% ls())){
    cat("loading kegg collection\n")
    load("data_to_be_deleted/kegg.collection/kegg.collection.Rdata")
  }
  if(length(kegg.collection) == 0)
    stop("Empty kegg.collection")
  cat("kegg.collection with ", length(kegg.collection), " pathways successfully loaded\n")

  cat("PSF computation started.\n")

  #genewise normalized data: considered as logFC.
  indata = env$indata

  #anti-log the indata to get the FC values
  indata.fc = 10^indata

  psf.results.collection = psf.from.env.indata(indata.fc)

}

#' Processs psf results output and calculates pvalues and some statitics
#' @param psf.results psf results output list
#' @export
process.psf.results <- function(psf.results){
  for(i in 1:length(psf.results)){
    if(length(psf.results[[i]]$signal.at.sink)>0){
      mean.psf = base::mean(unlist(psf.results[[i]]$signal.at.sink))
      psf.results[[i]]$mean.psf = mean.psf
      max.psf = base::max(unlist(psf.results[[i]]$signal.at.sink))
      psf.results[[i]]$max.psf = max.psf
      max.sinks = which(psf.results[[i]]$signal.at.sink == max.psf)
      psf.results[[i]]$max.sinks = names(max.sinks)
      if(!is.null(psf.results[[i]]$boot.mat)){
        p.values = sig.calc(psf.results[[i]]$signal.at.sink, psf.results[[i]]$boot.mat)
        psf.results[[i]]$p.values = p.values
        psf.results[[i]]$max.p.values = p.values[max.sinks]
        psf.results[[i]]$mean.p.value = 10^(base::mean(log10(p.values)))
      }

    } else {
      # cat("no signals at ", psf.results[[i]]$attrs$title)
    }
  }
  return(psf.results)
}


determine.sink.nodes.for.collection <- function(kegg.collection){
  for(i in 1:length(kegg.collection)){
    pathway = kegg.collection[[i]]
    cat(pathway$attrs$title, "\n")
    sink.nodes = determine.sink.nodes(pathway)
    kegg.collection[[i]]$sink.nodes = sink.nodes
  }
  return(kegg.collection)
}

#' Detects terminal nodes of the pathway
#' @param pathway pathway
#' @export
determine.sink.nodes <- function(pathway){
  sink.nodes =  NULL
  g = pathway$graph
  order = pathway$order$node.order
  for(node in graph::nodes(g)){
    node.children = graph::edges(g)[[node]]
    parent.nodes = NULL
    for(parent in graph::nodes(g)){
      if(node %in% graph::edges(g)[[parent]])
        parent.nodes = c(parent, parent.nodes)
    }
    isSinkNode = F
    if(length(parent.nodes) != 0){
      if(length(node.children) == 0)
        isSinkNode = T
      #         else{
      #           node.rank = order[[node]]
      #           for(child in node.children){
      #             isSinkNode = T
      #             child.rank = order[[child]]
      #             if(child.rank <= node.rank)
      #               isSinkNode = F
      #           }
      #         }
    }
    if(isSinkNode)
      sink.nodes = c(sink.nodes, node)
  }

  return(sink.nodes)
}


#' Returns ordered list of the nodes by their influence on the signal of specified nodes.
#' @param pathway Pathway onbject. 
#' @param exp_fc_matrix expression fold change matrix with gene etrez id rownames.
#' @param influenced_node sigle id of node or vector of node ids based on which partial influencse will be calculated.
#' @param influence_direction in which direction node affects the signal of target node. Possible values c("+", "-", "any"). Default value is "any".
#' @param node_combinations number of node combinations for partial influence analysis. Note: number of PSF calculations increases by the exponent of combinations(N nodes^combinations). Default value is 1.
#' @param nproc number of cpus to use for calculation. Default value is 1.
#' @param get_influence_matrix When set to true influence matrix will be returned instead of influencial nodes. Each column in influence matrix represent the log ratio of default and neutralized node(s) psf profile.
#' @import parallel
#' @export
calc_node_partial_influences <- function(pathway, exp_fc_matrix = NULL, influenced_node, influence_direction = "any", node_combinations = 1, nproc = 1, get_influence_matrix = FALSE) {
  
  if(!("signal.at.sink" %in% names(pathway))) {
    if(is.null(exp_fc_matrix)) {
      stop("Please provide FC matrix or pathway graph with evaluated activity")
    } else {
      
      entrez.column <- as.matrix(exp_fc_matrix[,1])
      
      graph::nodeData(pathway$graph, attr = "signal") <- 1
      
      g = map.gene.data(pathway$graph, entrez.column)
      
      psf_values <- unlist(graph::nodeData(psf.flow(g = pathway$graph, node.ordering = pathway$order, sink.nodes = pathway$sink.nodes, split = TRUE, sum = FALSE, mult_normalization = FALSE, tmm_mode = FALSE)$g, attr = "signal"))
    }
  } else {
    psf_values <- unlist(graph::nodeData(pathway$graph, attr = "signal"))
  }
  
  
  node_combs <- combn(graph::nodes(pathway$graph), node_combinations, simplify = F)
  
  psf_iterator <- function(node_combs) {
    iteration_graph <- pathway$graph
    
    graph::nodeData(iteration_graph, names(which(graph::nodeData(iteration_graph, node_combs, attr = "type") == "gene")), attr = "expression") <- 1
    
    unlist(graph::nodeData(psf.flow(iteration_graph, pathway$order, pathway$sink.nodes, split = TRUE, sum = FALSE)$graph, attr = "signal"))
  }
  
  influence_psf_mat <- parallel::mcmapply(psf_iterator, node_combs, mc.cores = nproc)
  
  colnames(influence_psf_mat) <- sapply(node_combs, function(x) {paste(x, collapse = "_")})
  
  psf_difference <- log(influence_psf_mat/psf_values)
  
  if(get_influence_matrix) {
    return(psf_difference)
  } else {
    if(influence_direction == "any") {
      ordered_influence_nodes <- sort(abs(colSums(psf_difference[influenced_node,, drop = FALSE]))[which(abs(colSums(psf_difference[influenced_node,, drop = FALSE])) > 0)], decreasing = T)
    }
    
    if(influence_direction == "+") {
      ordered_influence_nodes <- sort(colSums(psf_difference[influenced_node,, drop = FALSE])[which(colSums(psf_difference[influenced_node,, drop = FALSE]) > 0)], decreasing = T)
    }
    
    if(influence_direction == "-") {
      ordered_influence_nodes <- sort(colSums(psf_difference[influenced_node,, drop = FALSE])[which(colSums(psf_difference[influenced_node,, drop = FALSE]) < 0)])
    }
    
    return(ordered_influence_nodes)
  }
  
}